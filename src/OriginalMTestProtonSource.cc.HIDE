#include "MTestProtonSource.hh"

#include "Geant4/G4Event.hh"
#include "Geant4/G4GeneralParticleSource.hh"
#include "Geant4/G4ParticleTable.hh"
#include "Geant4/G4ParticleDefinition.hh"
#include "Geant4/globals.hh"
#include "Geant4/Randomize.hh"
#include "Geant4/G4ThreeVector.hh"
#include "Geant4/G4TwoVector.hh"

#include "TF1.h"

#include <algorithm>

using CLHEP::RandGeneral;

// Constructor
gm2strawtracker::MTestProtonSource::MTestProtonSource() :
  protonGun_(),
  verbosity_(0),
  protonInTurnProb_(0.),
  rfBucketPeriod_(0.),
  batchPeriod_(0.),
  turnPeriod_(0.),
  isInitialized_(false),
  spillEnded_(false),
  currentTurn_(0.),
  protonTimesToGen_(),
  plot_(false)
{

  //Instantiate gun
  //protonGun_ = new G4ParticleGun();
  protonGun_.reset( new G4ParticleGun() );

  //
  // Set default values of member parameters...
  //

  //FIXME AVOID REPRODUCTION WITH SERVICE WHILST MAINTAINING STAND-ALONE CAPABILITIES OF THIS CODE
  //FIXME AT LEAST SET TO 0

}

gm2strawtracker::MTestProtonSource::~MTestProtonSource() 
{ }


void gm2strawtracker::MTestProtonSource::SetupPlotting(std::map<std::string,TH1*> * histoMapPtr) {

  //Check initialization completed successfully
  if(!isInitialized_) {
    //TODO Move to better error mechanism, whilst maintaining stand-alone capabilities (e.g. no art)
    std::cerr << "MTestProtonSource : Cannot setup plotting, class not initialized" << std::endl;
    return;
  }


  //
  // Init plotting members
  //

  //Get ptr and set plot flag (if ptr is OK)
  if(histoMapPtr) {
    histoMapPtr_ = histoMapPtr; //From parent service
    plot_ = true;
  }
  else {
    std::cerr << "MTestProtonSource : Pointer to histo map is NULL, no histo plotting will be performed\n";
    return;
  }


  //
  // Book histos
  //

  //These histos show data that can't be accessed from the art records, so i useful for debugging

  std::string name = "";

  //Energy spread
  name = "h_deltaE"; 
  double deltaERange = 5*deltaP_*protonEnergy_; //Using 5 * deltaP as histo limits
  (*histoMapPtr_)[name.c_str()] = new TH1F(name.c_str(), "deltaE = E - <E> [GeV]", 
    100, -deltaERange/GeV, deltaERange/GeV);

  //MI turn
  name = "h_turnStartTime"; 
  (*histoMapPtr_)[name.c_str()] = new TH1F(name.c_str(), "Time of start of main injector turn for generated proton", 
    1000, bosTime_, (turnPeriod_*numMainInjectorTurnsPerSpill_) );
  name = "h_turn"; 
  (*histoMapPtr_)[name.c_str()] = new TH1F(name.c_str(), "Main injector turn of generated proton", 
    100, 0., numMainInjectorTurnsPerSpill_);
  name = "h_timeInTurn"; 
  (*histoMapPtr_)[name.c_str()] = new TH1F(name.c_str(), "Time of generated proton within turn", 
    1000, 0., turnPeriod_);

  //Booster batch
  name = "h_batch"; 
  (*histoMapPtr_)[name.c_str()] = new TH1F(name.c_str(), "Booster batch (within turn) of generated proton", 
    numBatchesPerTurn_, -0.5, numBatchesPerTurn_-0.5);
  name = "h_timeInBatch"; 
  (*histoMapPtr_)[name.c_str()] = new TH1F(name.c_str(), "Time of generated proton within batch", 1000, 0, batchPeriod_);

  //RF buckets and bunches
  name = "h_bucket"; 
  (*histoMapPtr_)[name.c_str()] = new TH1F(name.c_str(), "RF bucket (within batch) of generated proton", 
    numBucketsPerBatch_, -0.5, numBucketsPerBatch_-0.5);
  name = "h_timeInBucket"; 
  (*histoMapPtr_)[name.c_str()] = new TH1F(name.c_str(), "Time of generated proton within bucket", 1000, 0, rfBucketPeriod_);
  name = "h_timeInBunch"; 
  (*histoMapPtr_)[name.c_str()] = new TH1F(name.c_str(), "Time of generated proton within bunch", 1000, 0, bunchWidth_);
  name = "h_numProtonsInBucket"; 
  (*histoMapPtr_)[name.c_str()] = new TH1F(name.c_str(), "Number of protons in a given RF bucket", 10, -0.5, 9.5);

  //Beam spread
  name = "h_inputDistributionX"; 
  (*histoMapPtr_)[name.c_str()] = new TH1F(name.c_str(), "Input beam distribution form in X (transverse, beam frame) [mm]", 
    100, -100., 100.);
  name = "h_inputDistributionY"; 
  (*histoMapPtr_)[name.c_str()] = new TH1F(name.c_str(), "Input beam distribution form in Y (transverse, beam frame) [mm]", 
    100, -100., 100.);
  name = "h_beamDistributionX"; 
  (*histoMapPtr_)[name.c_str()] = new TH1F(name.c_str(), "Generated beam distribution in X (transverse, beam frame) [mm]", 
    100, -100., 100.);
  name = "h_beamDistributionY"; 
  (*histoMapPtr_)[name.c_str()] = new TH1F(name.c_str(), "Generated beam distribution in Y (transverse, beam frame) [mm]", 
    100, -100., 100.);

  //Plot input distribution
  if(plot_) {
    for(unsigned int i=0 ; i<1000 ; i++) {
      double xRand, yRand;
      distribution_->GetRandom2(xRand,yRand);
      histoMapPtr_->find("h_inputDistributionX")->second->Fill( xRand ); 
      histoMapPtr_->find("h_inputDistributionY")->second->Fill( yRand ); 
    }
  }

}


void gm2strawtracker::MTestProtonSource::initialize() {


  //
  // Set derived params from the user specified ones
  //

  //This computation is done here rather than in GeneratePrimaryVertex to avoid re[retion (e.g. for performance)

  //Determine probability of getting proton during a single MI turn. The probabolity is uniform throughout 
  //the spill and tuned by the accelerator team to give the requested number of protons during the spill)
  protonInTurnProb_ = (double)numProtonsRequestedPerSpill_ / (double)numMainInjectorTurnsPerSpill_;

  //Determine time period of one RF bucket
  rfBucketPeriod_ = (1. / rfBucketFrequency_ );

  //Determine time period of one booster batch
  batchPeriod_ = rfBucketPeriod_ * numBucketsPerBatch_;

  //Determine time period of one MI turn
  turnPeriod_ = rfBucketPeriod_ * numBucketsPerBatch_ * numBatchesPerTurn_;


  //
  // Check user defined params
  //

  //Check cannot get unphysical number of buckets
  if( (firstFilledBucketInBatch_+numFilledBucketsInBatch_) >= numBucketsPerBatch_ ) {
    std::cerr << "MTestProtonSource : Error in determining numbers of filled buckets per batch\n";
    return;
  }

  //Check cannot get unphysical number of batches
  if( (firstFilledBatchInTurn_+numFilledBatchesInTurn_) >= numBatchesPerTurn_ ) {
    std::cerr << "MTestProtonSource : Error in determining numbers of filled batches per turn\n";
    return;
  }

  //Check not requesting more protons than there are main innjector turns. This is not a use case for us, and code 
  //below isn't designed to handle it.
  if( numProtonsRequestedPerSpill_ > numMainInjectorTurnsPerSpill_ ) {
    std::cerr << "MTestProtonSource : Error: Requested more protons per spill than there are main injector turns\n";
    return;
  }

  //Check bunch width and offset are compatible with RF bucket width
  if( (bunchOffset_ < 0.) || ( bunchOffset_+bunchWidth_ > rfBucketPeriod_ ) ) {
    std::cerr << "MTestProtonSource : Error in bunch definition compared to bucket definition\n";
    return;
  }

  distribution_ = new TF2("distribution","[0]*TMath::Gaus(x,[1],[2])*TMath::Gaus(y,[3],[4]) + [5]*TMath::Gaus(x,[6],[7])*TMath::Gaus(y,[8],[9])",-100,100,-100,100);
  distribution_->SetParameters(beamNorm_, beamMeanX_, beamRMSX_, beamMeanY_, beamRMSY_, beamNormWide_, beamMeanXwide_, beamRMSXwide_, beamMeanYwide_, beamRMSYwide_);
  distribution_->SetNpx(1000);
  distribution_->SetNpy(1000);


  //
  // Normalize multiple occpuancy # proton weights to a probability
  //

  double sumWeights = std::accumulate(multipleOccupancyWeights_.begin(),multipleOccupancyWeights_.end(),(double)0.);//3rd arg gives type
  for( auto& weight : multipleOccupancyWeights_ ) weight /= sumWeights;


  //
  // Register initialization complete
  //

  isInitialized_ = true;

}


void gm2strawtracker::MTestProtonSource::GeneratePrimaryVertex(G4Event* evt) {

  //Check initialization completed successfully
  if(!isInitialized_) {
    //TODO Move to better error mechanism, whilst maintaining stand-alone capabilities (e.g. no art)
    std::cerr << "MTestProtonSource : Cannot generate particle, class not initialized" << std::endl;
    return;
  }


  //Create proton with MTest parameters (at aperture to beam hall)...

  //Get proton definition
  G4ParticleTable* particleTable = G4ParticleTable::GetParticleTable();
  G4ParticleDefinition* particle = particleTable->FindParticle("proton");
  protonGun_->SetParticleDefinition(particle);


  //
  // Set proton energy
  //

  //Use Gaussian spread about target energy to represent momentum spread of beam (dp/p = 2% from MTest webpage)
  double sigma = deltaP_*protonEnergy_;
  G4double genEnergy = G4RandGauss::shoot( protonEnergy_, sigma ); //TODO Truncate at 3sigma (common accerlator modelling practise)?
  protonGun_->SetParticleEnergy( genEnergy );
  if(plot_) histoMapPtr_->find("h_deltaE")->second->Fill( (genEnergy-protonEnergy_)/GeV ); 


  //
  // Set proton direction and position
  //


  //Generate proton transverse position relative to beam mean within beam local coords (where +z is beam direction, 
  //[x=0,y=0] is beam centre)
  //G4TwoVector protonPosLocalToBeam( G4RandGauss::shoot( 0.*mm, beamRMSX_ ) ,
  //                                  G4RandGauss::shoot( 0.*mm, beamRMSY_ ) );

  //FIXME: Is using G4RandGuass::shoot in this manner problematic?
  // see: http://mu2e.fnal.gov/public/hep/computing/Random.shtml#fireShoot
  // BK, Nov 2012

  double xRand;
  double yRand;
  distribution_->GetRandom2(xRand,yRand);

  G4TwoVector protonPosLocalToBeam( xRand*mm , yRand*mm );
 
  //Now transform to world frame. Currently have particle at z=0 (beam dir = +z), y,x = generated transverse position. 
  //(e.g. in beam frame). Need to rotate and translate this to  put the particle at the beam aperture in MTest, and 
  //pointing in the specified direction...

  //Start from beam frame
  G4ThreeVector protonPosBeamFrame( protonPosLocalToBeam.x(), protonPosLocalToBeam.y(), 0 );

  //Rotate to point in specified direction in parent (world) frame
  protonPosBeamFrame.rotateUz(beamDirection_.unit());

  //Translate proton position to 3D initial position in world (e.g. beam aperture)
  protonPosBeamFrame += aperturePosition_;

  protonGun_->SetParticlePosition(protonPosBeamFrame);
  protonGun_->SetParticleMomentumDirection(beamDirection_);


  //
  // Set proton arrival time
  //

  /* Beam path is as follows... (see http://www-ppd.fnal.gov/MTBF-w/beam/delivery.html)
    
     - Protons are accelerated in 53MHz RF buckets. The protons within one bucket are called a bunch (typically
       smaller width that period of one RF bucket, as want to move bunch within bucket depending on whether you
       are accelerating or storing particles).
     - Protons from linac enter the booster (circular), where one turn of particles consists of 84 RF buckets 
       (1.6us total width), and is called a boost batch. Not all RF buckets are filled with protons however 
       (depends on accelerator operations, 82 is common). The particles are accelerated to 8GeV.
     - Booster batches enter main injector (MI), which holds exactly 7 consecutive booster batches (11.2us total
       width, e.g. one MI turn). 
     - Protons are resonantly extracted from the MI into a beam line that serves SeaQuest and MTest (at least in
       2015). The number of booster batches this extraction is drawn from depends on SeaQuest operations, in 2015 
       (full SeaQuest running) this will be 6 of the 7 batches in the MI.
     - Exactly what is extracted from these batches depends on SeaQuest operations, but during full SeaQuest 
       running typically protons are extracted from ~approx. all filled RF buckets in the used batches (so 6 of 7),
       and then a small amount of these are filtered off for MTest (the rest goes to SeaQuest). 
     - The protons for MTest are then passed through a pin hole collimator before the MTest beam hall where most 
       are lost, resulting in an approx. 2mm Gaussian beam at MTest.
     - This extraction to MTest occurs during a slow spill, which is for ~4s every 60s. More precisely, the slow 
       spill is ~360,000 MI turns (each turn is ~11.2us). Between slows spills no particles arrive at MTest.
     - The number of protons that reach MTest can be controlled by the accelerator team. The MTest user can request 
       this number from the control room, with 50,000-150,000 per spill being typical values.
     - The number of protons per spill is less than the number of MI turns, so the user should not expect a proton 
       every turn. The acclerator team control the time distribution of these protons to MTest such that their arrival
       times are approximately unfiform throughout the spill. They also try to only deliver a single proton in a given
       turn to MTest. However the difficulties in extracting such a small amount of beam and the uncertainty involved 
       with using a collimator mean that there is an ~35% probability of a multiple occupancy event where more than 
       one (normally 2) protons arrive during a single RF bucket (probability increases at large intensities). 
     - Note that these double/multiple occupancy protons could be from any filled bucket in the turn (e.g. they are 
       not doubly extracted from the same bucket or batch necessarily or anything like that).
     - Note also that there is a learn-in time for the extraction process each time the accelerator restarts. This
       affects the numbers mentioned above until stable.
     - Due to the aforementioned issues with extracting the small amount of beam, there may be significant variation 
       in the number of particles arriving at MTest relative to the number requested by the user. Note that the number
       arriving at MTest is measured by a counter somewhere in MTest.
   */

  //Note that this function is called once per event, and only want one proton per event. Generation scheme is to 
  //increment MI turns until generate a proton in one, and then generates arrival times for all protons that turn 
  //(e.g. includes double occupancy). Each new event uses one of these times, and when all have been used a new set 
  //is generated for the next cycle where protons are generated.

  //If no remaining protons times from last event, generate new one(s)
  if( protonTimesToGen_.size() == 0 ) {

    //No buffered times, generate new one(s)...

    //If spill is over (e.g. max number of MI turns passed) don't generate any new particles
    if(spillEnded_) {
      std::cout << "MTestProtonSource : End of spill reached\n";
      return;
    }

    //Generate next MI turn a proton arrives at MTest during
    //Increment turn number, checking each time whetherto generate a particle, and if not repeat 
    while( G4RandFlat::shoot(0.,1.) > protonInTurnProb_ ) {
      currentTurn_++;
    }

    //Generate arrival RF bucket at MTest for this event proton(s) (multiple occupancy drawm from same bucket)
    //Uniformly randomly sampling from filled bunches and batches...

    //Get start time of current turn
    G4double startOfTurnTime = bosTime_ + (currentTurn_ * turnPeriod_);
      
    //Generate booster batch p+ is in and start time of this batch within turn
    unsigned int batch = firstFilledBatchInTurn_ + floor( G4RandFlat::shoot(0.,numFilledBatchesInTurn_) );
    double batchTimeInTurn = batch * batchPeriod_;

    //Generate bucket/bunch (a bunch is the protons within the RF bucket) p+ is in (within batch) 
    //and start times of these within batch
    unsigned int bucket = firstFilledBucketInBatch_ + floor( G4RandFlat::shoot(0.,numFilledBucketsInBatch_) );
    double bucketTimeInBatch = bucket * rfBucketPeriod_;
    double bunchTimeInBatch = bucketTimeInBatch + bunchOffset_;

    //Get start time of this bucket
    G4double bucketStartTime = startOfTurnTime + (batch*batchPeriod_) + (bucket*rfBucketPeriod_);

    //Generate whether or not this is a multiple occupancy RF bucket
    int numProtonsThisBucket = 1;
    if( G4RandFlat::shoot(0.,1.) < multipleOccupancyProb_ ) {

      //Generate number of protons in this multiple occupancy event
      double random = G4RandFlat::shoot(0.,1.);
      double runningWeightSum = 0.;
      for( auto weight : multipleOccupancyWeights_ ) { //Loop through probabilities for various # protons
        numProtonsThisBucket++;
        runningWeightSum += weight;
        if(random < runningWeightSum) break; //Use this # protons
      }

    }//if multiple occupancy

    if(plot_) histoMapPtr_->find("h_numProtonsInBucket")->second->Fill( numProtonsThisBucket ); 

    //Generate the times within the RF bucket for all protons (either single or multiple occupancy)
    for(int i(0) ; i<numProtonsThisBucket ; i++) {

      //Uniformly randomly sample a time from the bunch within the bucket to get this proton time (note 
      //that bunch width typically is smaller than total width of bucket)
      G4double protonTimeInBunch = G4RandFlat::shoot(0.,bunchWidth_);

      //Get the global time of this proton
      G4double protonTime = startOfTurnTime + batchTimeInTurn + bunchTimeInBatch + protonTimeInBunch;

      //Add this generated time to vector so that it can be used to a proton event
      protonTimesToGen_.push_back(protonTime);

      //Fill some histos relating to this proton for debugging (this information isn't in tracking
      //action art record so cannot be directly accessed by analyzers later
      if(plot_) {
        histoMapPtr_->find("h_turnStartTime")->second->Fill( startOfTurnTime ); 
        histoMapPtr_->find("h_turn")->second->Fill( currentTurn_ ); 
        histoMapPtr_->find("h_timeInTurn")->second->Fill( protonTime-startOfTurnTime ); 
        histoMapPtr_->find("h_batch")->second->Fill( batch ); 
        histoMapPtr_->find("h_timeInBatch")->second->Fill( bunchTimeInBatch+protonTimeInBunch ); 
        histoMapPtr_->find("h_bucket")->second->Fill( bucket ); 
        histoMapPtr_->find("h_timeInBucket")->second->Fill( bunchOffset_+protonTimeInBunch ); 
        histoMapPtr_->find("h_timeInBunch")->second->Fill( protonTimeInBunch ); 
        histoMapPtr_->find("h_beamDistributionX")->second->Fill( protonPosLocalToBeam.x() ); 
        histoMapPtr_->find("h_beamDistributionY")->second->Fill( protonPosLocalToBeam.y() ); 
      }

    }//num protons this turn loop

    //Sort the generated times into descending order(e.g. want back of vector to be earliest time)
    std::sort(protonTimesToGen_.begin(), protonTimesToGen_.end(), std::greater<G4double>());

    //Set current turn read for next event where proton time generation takes place
    currentTurn_++; 

    //Check if have reached end of spill
    if( currentTurn_ >= numMainInjectorTurnsPerSpill_ ) spillEnded_ = true;

  }//end if size == 0

  //Now have at least proton time for this event (either because have leftover multiple occupancy 
  //protons from last event, or have generated a new turn this event). Use last one in vector (e.g. 
  //earliest time as vector sorted in descending order) as proton time for this event
  protonGun_->SetParticleTime(protonTimesToGen_.back());
  protonTimesToGen_.pop_back(); //Remove this time now have used it for a proton


  //TODO Add noise? Maybe make noise producer, or add to digitizer


  //
  // Generate proton with this properties and fire it from particle gun
  //

  protonGun_->GeneratePrimaryVertex( evt );

}

